### UCiNet


> * source: Borgatti, S.P., Everett, M.G. and Freeman, L.C. 2002. Ucinet for Windows: Software for Social Network Analysis. Harvard, MA: Analytic Technologies. https://sites.google.com/site/ucinetsoftware/home
> * our discussion relies on **force-directed drawing (FDD) algorithms**, concretely the graph layout algorithms (GLA) that are built into the UCINET software package. FDD algorithms proceed in a way that is rather different from MDS (multi-dimensional scaling). They do not attempt to map a network’s structure (i.e. its relations of similarities respectively dissimilarities) in terms of the raw distances of the proximity matrix, yet conceive of it in terms of energy. Core to minimizing energy is strain. Typically, FDD algorithms are therefore referred to as ‘spring embedders’. As the name suggests, they act as a system of springs, stretched between posts in a force field. If two posts with a spring between them are placed too close to each other, the spring is compressed and tries to push the posts apart (a property we also refer to as ‘node repulsion’). If, on the other hand, the posts are too far apart, the spring is stretched and tries to pull the posts together (a property called ‘node attraction’). In essence, the algorithms are methods of locating the posts in such a way as to bring the repulsive and attractive forces throughout the entire field in a stable, balanced state.

> * **PRO-TIP**: When preparing your spreadsheets for analysis in UCiNet, but also simply in order to get a better grasp of your data, it is handy to keep in mind a few simple calculations matrix calculations. Imagine, for instance, that one has followed the rules for calculating the flow-of-funds between two branches `X` and `Y`, according to the rules [outlined earlier](https://github.com/michaelschiltz/even-keel/blob/master/1.%20database%20architecture.md#a-flow-of-funds-analysis).
> * Having done this, we still have no number expressing the 'net' transfer between branches. Instead, we have 2 numbers, i.e. one expressing the flow `X->Y` and `Y->X`. See below, and note amounts `a` and `b`:

|   | X   | Y   |
|---|-----|-----|
| **X** | -   | `a` |
| **Y** | `b` | -   |

> * The net number can be obtained as follows. First, [use the `TRANSPOSE` function in your spreadsheet program](https://gsuitetips.com/tips/sheets/how-to-transpose-data-in-a-google-spreadsheet/) (we have used google sheets, as it is both free but also [less error prone than Microsoft Excel](http://blogs.lse.ac.uk/impactofsocialsciences/2017/02/22/excel-is-threatening-the-quality-of-research-data-data-packages-are-here-to-help/); and compare this [github page of crazy excel stories](https://github.com/jennybc/scary-excel-stories)).
> * Then, subtract the transposed matrix from the original one. The result is one matrix, with mirroring results of transfers in the parts above and under the diagonal (i.e. the diagonal of `-`-values that is the result of forbidding the possibility of loops, i.e. branches sending amounts to themselves (as would the case in, for instance, an amount sent from `X` to `X`)).
> * Last, clean the resulting matrix by eliminating all negative amounts. This can be done manually, but this is obviously prone to mistakes, hence it is better to use `logical expressions`, i.e. the [`IF`-function in google sheets](https://support.google.com/docs/answer/3093364?hl=en). In this case, data are formatted according to the following syntax: `IF(logical_expression, value_if_true, value_if_false)`. Concretely, we have used `=if(value<0,0,value)`, whereby `value` is the number of the spreadsheet cell to which the logical expression applies.
> * This technique is especially helpful because of a caveat in contemporary Social Network Anlysis, i.e. the difficuly to conceive of *negative flows*. Admittedly, there seems to have been [some improvement in this respect], but this is a far cry from applications in, for instance, finance, where negative flows (for example: somebody initiating a negative flow by overdrawing his/her account) are very common.




### R-project & Python

> * [NetworkX](https://networkx.github.io/) is a Python library for studying graphs and networks, enabling a variety of lay-outs for network graphs.
> * documentation about lay-out possibilities with the [igraph package](http://igraph.org/) for R and Python can be found [here](http://igraph.org/c/doc/igraph-Layout.html).
> * there exist separate tutorials for [python](http://igraph.org/python/doc/tutorial/tutorial.html) and [R](http://igraph.org/r/doc/)
> * note that, as described above, our analysis exclusively uses force-directed layouts as proposed by, among others, [Kamada-Kawai](https://linkinghub.elsevier.com/retrieve/pii/0020019089901026) and [Fruchterman-Reingold](http://onlinelibrary.wiley.com/doi/10.1002/spe.4380211102/abstract). Tutorials for R include code snippets for [KK](http://igraph.org/r/doc/layout_with_kk.html) and [FR](http://igraph.org/r/doc/layout_with_fr.html); see [here](http://igraph.org/python/doc/igraph-pysrc.html#Graph.layout_kamada_kawai) and [here](http://igraph.org/python/doc/igraph-pysrc.html#Graph.layout_fruchterman_reingold) for Python.
> * As always, [StackOverflow](https://stackoverflow.com/) is a great means for exploring the potential and limitations of the packages, possible visualizations and so on.
